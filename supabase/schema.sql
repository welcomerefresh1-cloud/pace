-- Create a table for public profiles
create table profiles (
  id uuid references auth.users on delete cascade not null primary key,
  updated_at timestamp with time zone,
  username text unique,
  full_name text,
  avatar_url text,
  role text check (role in ('admin', 'student', 'employer')) default 'student',
  
  constraint username_length check (char_length(username) >= 3)
);

-- Set up Row Level Security (RLS)
alter table profiles enable row level security;

create policy "Public profiles are viewable by everyone." on profiles
  for select using (true);

create policy "Users can insert their own profile." on profiles
  for insert with check ((select auth.uid()) = id);

create policy "Users can update own profile." on profiles
  for update using ((select auth.uid()) = id);

-- Alumni specific details
create table alumni (
  id uuid references profiles(id) on delete cascade not null primary key,
  graduation_year int,
  course text,
  student_id text,
  current_job_title text,
  linkedin_url text
);

alter table alumni enable row level security;

create policy "Alumni profiles viewable by admins and owner" on alumni
  for select using (
    (select auth.uid()) = id or 
    exists (select 1 from profiles where id = (select auth.uid()) and role = 'admin')
  );

create policy "Alumni can update own profile" on alumni
  for update using ((select auth.uid()) = id);
  
create policy "Alumni can insert own profile" on alumni
  for insert with check ((select auth.uid()) = id);

-- Employers
create table employers (
  id uuid references profiles(id) on delete cascade not null primary key,
  company_name text,
  company_website text,
  company_description text
);

alter table employers enable row level security;

create policy "Employer profiles viewable by everyone" on employers
  for select using (true);

create policy "Employers can update own profile" on employers
  for update using ((select auth.uid()) = id);
  
create policy "Employers can insert own profile" on employers
  for insert with check ((select auth.uid()) = id);

-- Job Postings
create table job_postings (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  employer_id uuid references employers(id) not null,
  title text not null,
  description text not null,
  requirements text,
  location text,
  salary_range text,
  job_type text check (job_type in ('full-time', 'part-time', 'contract', 'internship')),
  is_active boolean default true
);

alter table job_postings enable row level security;

create policy "Job postings are viewable by everyone" on job_postings
  for select using (true);

create policy "Employers can insert own job postings" on job_postings
  for insert with check ((select auth.uid()) = employer_id);

create policy "Employers can update own job postings" on job_postings
  for update using ((select auth.uid()) = employer_id);

-- Skills
create table skills (
  id bigint generated by default as identity primary key,
  name text unique not null
);

alter table skills enable row level security;

create policy "Skills are viewable by everyone" on skills
  for select using (true);

-- Alumni Skills Junction
create table alumni_skills (
  alumni_id uuid references alumni(id) on delete cascade not null,
  skill_id bigint references skills(id) on delete cascade not null,
  primary key (alumni_id, skill_id)
);

alter table alumni_skills enable row level security;

create policy "Alumni skills viewable by everyone" on alumni_skills
  for select using (true);

create policy "Alumni can manage their own skills" on alumni_skills
  for all using ((select auth.uid()) = alumni_id);

-- Events
create table events (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  title text not null,
  description text,
  event_date timestamp with time zone not null,
  location text,
  organizer_id uuid references profiles(id)
);

alter table events enable row level security;

create policy "Events are viewable by everyone" on events
  for select using (true);

create policy "Admins can manage events" on events
  for all using (
    exists (select 1 from profiles where id = (select auth.uid()) and role = 'admin')
  );

-- Event Registrations
create table event_registrations (
  event_id bigint references events(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,
  registered_at timestamp with time zone default timezone('utc'::text, now()) not null,
  primary key (event_id, user_id)
);

alter table event_registrations enable row level security;

create policy "Users can register for events" on event_registrations
  for insert with check ((select auth.uid()) = user_id);

create policy "Users can view their own registrations" on event_registrations
  for select using ((select auth.uid()) = user_id);

create policy "Admins can view all registrations" on event_registrations
  for select using (
    exists (select 1 from profiles where id = (select auth.uid()) and role = 'admin')
  );

-- Function to handle new user signup
create function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, full_name, avatar_url, username)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url', new.email);
  return new;
end;
$$ language plpgsql security definer;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
